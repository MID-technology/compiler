# O Language Lexer

Лексический анализатор для объектно-ориентированного языка O.

## Описание

Этот лексер распознает токены языка O согласно спецификации Project_O.pdf и поддерживает расширенный синтаксис из примеров.

## Поддерживаемые токены

### Ключевые слова
- `class`, `is`, `end`, `extends`
- `var`, `method`, `this`, `base`
- `if`, `then`, `else`
- `while`, `loop`
- `return`
- `true`, `false`

### Литералы
- **Целые числа**: `0`, `42`, `123`
- **Вещественные числа**: `3.14`, `0.5`
- **Булевы значения**: `true`, `false`
- **Строки**: `"hello"`, `"hello\" world"` (с поддержкой экранирования)

### Операторы
- `:` - двоеточие
- `:=` - присваивание
- `=` - равенство/присваивание (расширенный синтаксис)
- `=>` - короткое тело метода
- `.` - доступ к членам
- `,` - разделитель
- `()` - скобки
- `[]` - квадратные скобки
- `{}` - фигурные скобки
- `<>` - угловые скобки (для обобщенных типов)

### Комментарии
- `//` - однострочный комментарий
- `/* */` - многострочный комментарий (с поддержкой вложенности)

## Структура проекта

```
lexer/
├── CMakeLists.txt          # Конфигурация сборки
├── README.md               # Этот файл
├── include/
│   ├── token.h            # Определение токенов
│   └── lexer.h            # Интерфейс лексера
├── src/
│   ├── token.cpp          # Реализация токенов
│   ├── lexer.cpp          # Реализация лексера
│   └── main.cpp           # Демо-программа
└── tests/
    ├── CMakeLists.txt     # Конфигурация тестов
    └── test_lexer.cpp     # Unit-тесты
```

## Сборка

```bash
cd lexer
mkdir build
cd build
cmake ..
cmake --build .
```

## Использование

### Запуск демо-программы

```bash
./lexer_demo ../path/to/file.ol
```

### Запуск тестов

**Unit-тесты:**
```bash
./tests/lexer_tests
```

Или через CTest:
```bash
ctest --output-on-failure
```

**Тестирование на примерах:**
```bash
cmake --build . --target test_examples
```

**Запуск всех тестов (unit + примеры):**
```bash
cmake --build . --target test_all
```

## Примеры использования в коде

```cpp
#include "lexer.h"
#include <iostream>

using namespace olang;

int main() {
    std::string source = R"(
        class Main is
            var x: Integer(42)
        end
    )";
    
    try {
        Lexer lexer(source);
        std::vector<Token> tokens = lexer.tokenize();
        
        for (const auto& token : tokens) {
            std::cout << token << std::endl;
        }
    } catch (const LexerError& e) {
        std::cerr << "Error at " << e.line() << ":" << e.column() 
                  << " - " << e.what() << std::endl;
    }
    
    return 0;
}
```

## Обработка ошибок

Лексер выбрасывает исключение `LexerError` при обнаружении:
- Неожиданных символов
- Незакрытых строковых литералов
- Незакрытых комментариев
- Неверного формата чисел

Исключение содержит информацию о позиции ошибки (строка и колонка).

## Особенности реализации

1. **Вложенные комментарии**: Поддерживается вложенность блочных комментариев `/* /* */ */`
2. **Экранирование в строках**: Поддерживаются `\"`, `\\`, `\n`, `\t`, `\r`
3. **Позиционирование**: Каждый токен содержит информацию о строке и колонке
4. **Расширенный синтаксис**: Поддержка `=`, `<>`, `base` из примеров кода

## Следующие шаги

После завершения лексера планируется реализация:
1. Парсера (синтаксический анализ)
2. AST (абстрактное синтаксическое дерево)
3. Семантического анализатора
4. Генератора кода или интерпретатора